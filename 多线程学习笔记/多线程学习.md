### J.U.C简介

J.U.C即`java.util.concurrent`包，是JDK的核心工具包。

整个`java.util.concurrent`包，按功能可以大致划分：

- juc-locks 锁
- juc-atomic 原子类
- juc-sync 同步器
- juc-collections 集合
- juc-executors 执行器

---

### juc-locks 锁

![锁](img\QQ截图20200923155836.png)

#### 锁接口说明

juc-locks锁框架中一共就三个接口：Lock、Condition、ReadWriteLock 

##### Lock接口

Lock接口可以视为synchronized的增强版，提供了更灵活的功能。该接口提供了限时锁等待、锁中断、锁尝试等功能，主要定义了如下接口：

```java
void		lock();	//获得锁
void		lockInterruptibly();//获得锁，但是可以被打断
Condition 	newCondition();	//获得信号量
boolean		tryLock();	//测试是否能获得锁
boolean		tryLock(long time, TimeUnit unit);
void		unlock();	//释放锁
```

需要注意`lock()`和`lockInterruptibly()`这两个方法的区别： 

> `lock()方法`类似于使用synchronized关键字加锁，如果锁不可用，将当前线程阻塞，在获得锁之前，该线程将一直处于休眠状态。
> 
> `lockInterruptibly()`方法顾名思义，就是如果锁不可用，那么当前正在等待的线程是可以被其他信号中断的，这比synchronized关键字更加灵活。 

##### Condition接口

Condition可以看做是Obejct类的`wait()`、`notify()`、`notifyAll()`方法的替代品，与Lock配合使用。 

当线程执行condition对象的`await`方法时，当前线程会立即释放锁，并进入对象的等待区，等待其它线程唤醒或中断。 与操作系统相似，主要使用`await`和`signal`方法。接口定义如下：

```java
void	await();	//等待，直到得到信号或者被中断
boolean	await(long time, TimeUnit unit); //等待，直到得到信号或者被中断或者达到最长等待时间time
long	awaitNanos(long nanosTimeout);	//微秒等待
void	awaitUninterruptibly();		//等待，不可被中断
boolean	awaitUntil(Date deadline);	//等待，直到得到信号或者被中断或者到达指定时间
void	signal();		//唤醒一个等待线程
void	signalAll();	//唤醒所有等待线程
```

为了防止虚假唤醒，一般写`while`等待：

```java
while (count == items.length)
	notFull.await();
```

##### ReadWriteLock接口

读写锁定，读和写分别进行锁定。有读锁定的时候，可以继续读，但是不能写；有写锁定的时候，不能进行读写。接口如下：

```java
Lock	readLock();	//读锁定
Lock	writeLock();//写锁定
```



#### 可重入锁(ReentrantLock)

ReentrantLock类，实现了`Lock`接口，是一种**可重入**的**独占锁**，它具有与使用 `synchronized` 相同的一些基本行为和语义，但功能更强大。 

ReentrantLock类的构造器提供了指定**公平策略** / **非公平策略**的功能，默认为**非公平策略**。

> **公平策略：**在多个线程争用锁的情况下，公平策略倾向于将访问权授予等待时间最长的线程。也就是说，相当于有一个线程等待队列，先进入等待队列的线程后续会先获得锁，这样按照“先来后到”的原则，对于每一个等待线程都是公平的。 
>
> **非公平策略：**在多个线程争用锁的情况下，能够最终获得锁的线程是随机的（由底层OS调度）。

 *注意：一般情况下，使用公平策略的程序在多线程访问时，总体吞吐量（即速度很慢，常常极其慢）比较低，因为此时在线程调度上面的开销比较大。* 

举个栗子：

假设采用公平策略，线程A首先获取了锁，线程B和线程C等待获取锁 。当线程A释放锁时，线程B将经历从`挂起->唤醒`的线程调度过程，线程调度非常耗时 。

 在线程B的`挂起->唤醒`阶段：

1. 如果采用非公平策略，那么线程C可以立即获取锁，线程C使用完并释放锁后，线程B可能才刚唤醒完成；此时线程B又可以去获取锁，这样线程B和线程C的效率都得到提升，系统吞吐量提升； 
2. 如果采用公平策略，线程C即使可用，也要等到线程调度完成，整个系统的吞吐量降低。 

非公平锁只是在进入队列之前尝试去CAS修改state，如果失败了才会进入队列排队，进入队列后则和公平锁一样等待上一个线程释放锁被唤醒。 

因此，当线程持有锁的时间相对较长或者线程请求锁的平均时间间隔较长时，可以考虑使用公平策略。此时线程调度产生的耗时间隔影响会较小。

**使用方式**

```java
class X {
    private final ReentrantLock lock = new ReentrantLock();
    // ...
    public void m() {
        lock.lock(); //锁定
        try {
            // ... method body
        } finally {
            lock.unlock();	//释放
        }
    }
}
```



#### 可重入读写锁(ReentrantReadWriteLock)

ReentrantReadWriteLock类，顾名思义，是一种读写锁，它是`ReadWriteLock`接口的直接实现，该类在内部实现了具体**独占锁**特点的写锁，以及具有**共享锁**特点的读锁 。

ReentrantReadWriteLock类具有如下特点： 

1. 支持公平/非公平策略
2. 支持锁重入：①同一读线程在获取了读锁后还可以获取读锁；②同一写线程在获取了写锁之后既可以再次获取写锁又可以获取读锁 
3. 支持锁降级：写锁可以降级成读锁，读锁不能升级成写锁 
4. Condition条件支持：可以通过`newCondition()`方法获取Condition对象，但是只有写锁可以获取Condition

使用实例：

```java
public class RWTreeMap {
    private final Map<String, Data> m = new TreeMap<String, Data>();
    private final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();
    private final Lock r = rwl.readLock();	//获得读锁
    private final Lock w = rwl.writeLock(); //获得写锁
 
    public Data get(String key) {
        r.lock();	//读锁定
        try {
            return m.get(key);
        } finally {
            r.unlock();	//读释放
        }
    }
 
    public String[] allKeys() {
        r.lock();
        try {
            return (String[]) m.keySet().toArray();
        } finally {
            r.unlock();
        }
    }
 
    public Data put(String key, Data value) {
        w.lock();	//写锁定
        try {
            return m.put(key, value);
        } finally {
            w.unlock();	//写释放
        }
    }
 
    public void clear() {
        w.lock();
        try {
            m.clear();
        } finally {
            w.unlock();
        }
    }
}
```



#### LockSupport

LockSupport类的核心方法其实就两个：`park()`和`unpark()`，其中`park()`方法用来阻塞当前调用线程，`unpark()`方法用于唤醒指定线程，与Object的wait()和signal()方法不同，它可以针对指定的线程进行阻塞和唤醒。

> LockSupport类使用了一种名为Permit（许可）的概念来做到阻塞和唤醒线程的功能，可以把许可看成是一种(0,1)信号量（Semaphore），但与 Semaphore 不同的是，许可的累加上限是1。
>
> 初始时，permit为0，当调用`unpark()`方法时，线程的permit加1，当调用`park()`方法时，如果permit为0，则调用线程进入阻塞状态。 
>
> 简单来说，它是一种不可重入的互斥锁。

通过LockSupport的这两个方法，可以很方便的阻塞和唤醒线程。但是LockSupport的使用过程中还需要注意以下几点： 

1. `park`方法的调用一般要写在方法循环判断体里面， 这样做是为了防止线程被唤醒后，不进行判断而意外继续向下执行；
2. `park`方法会响应中断，但是不会抛异常；
3. `park`的重载方法`park(Object blocker)`会传入一个blocker对象，该对象提供监视、诊断工具



#### AQS(AbstractQueuedSynchronizer)

##### 简介

AQS是整个`java.util.concurrent`包的核心，该包中的大多数同步器都是基于AQS来构建的，AQS框架提供了一套通用的机制来管理同步状态（synchronization state）、阻塞/唤醒线程、管理等待队列。

AQS框架，分离了构建同步器时的一系列关注点，它的所有操作都围绕着资源——同步状态(synchronization state)来展开，并替用户解决了如下问题：

1. 资源是可以被同时访问？还是在同一时间只能被一个线程访问？（共享/独占功能）
2. 访问资源的线程如何进行并发管理？（等待队列）
3. 如果线程等不及资源了，如何从等待队列退出？（超时/中断）

这其实是一种典型的模板方法设计模式：父类（AQS框架）定义好骨架和内部操作细节，具体规则由子类去实现。

 AQS框架将剩下的一个问题留给用户：
*什么是资源？如何定义资源是否可以被访问？*

 几个常见的同步器对这一问题的定义： 

| 同步器                 | 资源的定义                                                   |
| ---------------------- | ------------------------------------------------------------ |
| ReentrantLock          | 资源表示独占锁。State为0表示锁可用；为1表示被占用；为N表示重入的次数 |
| CountDownLatch         | 资源表示倒数计数器。State为0表示计数器归零，所有线程都可以访问资源；为N表示计数器未归零，所有线程都需要阻塞。 |
| Semaphore              | 资源表示信号量或者令牌。State≤0表示没有令牌可用，所有线程都需要阻塞；大于0表示由令牌可用，线程每获取一个令牌，State减1，线程没释放一个令牌，State加1。 |
| ReentrantReadWriteLock | 资源表示共享的读锁和独占的写锁。state逻辑上被分成两个16位的unsigned short，分别记录读锁被多少线程使用和写锁被重入的次数。 |

综上所述，AQS框架提供了以下功能： 

###### 1. 提供一套模板框架

由于并发的存在，需要考虑的情况非常多，因此能否以一种相对简单的方法来完成这两个目标就非常重要，因为对于用户（AQS框架的使用者来说），很多时候并不关心内部复杂的细节。而AQS其实就是利用模板方法模式来实现这一点，AQS中大多数方法都是final或是private的，也就是说Doug Lea并不希望用户直接使用这些方法，而是只覆写部分模板规定的方法。
AQS通过暴露以下API来让让用户自己解决上面提到的“**如何定义资源是否可以被访问**”的问题： 

| 钩子方法          | 描述               |
| ----------------- | ------------------ |
| tryAcquire        | 排它获取（资源数） |
| tryRelease        | 排它释放（资源数） |
| tryAcquireShared  | 共享获取（资源数） |
| tryReleaseShared  | 共享获取（资源数） |
| isHeldExclusively | 是否排它状态       |

###### 2. 支持中断、超时

使用了AQS框架的同步器，都支持下面的操作： 

- 阻塞和非阻塞同步
- 可选的超时设置，让调用者可以放弃等待
- 可中断的阻塞操作

###### 3. 支持独占模式和共享模式

###### 4.支持Condition条件等待

Condition接口可以看做是Object类的wait()、notify()、notifyAll()方法的替代品，与Lock搭配使用。



##### AQS方法说明

###### CAS操作

CAS，即CompareAndSet，在Java中CAS操作的实现都委托给一个名为UnSafe类，通过该类可以实现对字段的原子操作。

| 修饰符               | 方法名                  | 描述                    |
| -------------------- | ----------------------- | ----------------------- |
| protected final      | compareAndSetState      | CAS修改同步状态值       |
| private final        | compareAndSetHead       | CAS修改等待队列的头指针 |
| private final        | compareAndSetTail       | CAS修改等待队列的尾指针 |
| private static final | compareAndSetWaitStatus | CAS修改结点的等待状态   |
| private static final | compareAndSetNext       | CAS修改结点的next指针   |

###### 等待队列的核心操作

| 修饰符  | 方法名              | 描述                 |
| ------- | ------------------- | -------------------- |
| private | enq                 | 入队操作             |
| private | addWaiter           | 入队操作             |
| private | setHead             | 设置头结点           |
| private | unparkSuccessor     | 唤醒后继结点         |
| private | doReleaseShared     | 释放共享结点         |
| private | setHeadAndPropagate | 设置头结点并传播唤醒 |

###### 资源的获取操作

| 修饰符         | 方法名                       | 描述                              |
| -------------- | ---------------------------- | --------------------------------- |
| private        | cancelAcquire                | 取消获取资源                      |
| private static | shouldParkAfterFailedAcquire | 判断是否阻塞当前调用线程          |
| final          | acquireQueued                | 尝试获取资源,获取失败尝试阻塞线程 |
| private        | doAcquireInterruptibly       | 独占地获取资源（响应中断）        |
| private        | doAcquireNanos               | 独占地获取资源（限时等待）        |
| private        | doAcquireShared              | 共享地获取资源                    |
| private        | doAcquireSharedInterruptibly | 共享地获取资源（响应中断）        |
| private        | doAcquireSharedNanos         | 共享地获取资源（限时等待）        |

| 修饰符       | 方法名                     | 描述                       |
| ------------ | -------------------------- | -------------------------- |
| public final | acquire                    | 独占地获取资源             |
| public final | acquireInterruptibly       | 独占地获取资源（响应中断） |
| public final | acquireInterruptibly       | 独占地获取资源（限时等待） |
| public final | acquireShared              | 共享地获取资源             |
| public final | acquireSharedInterruptibly | 共享地获取资源（响应中断） |
| public final | tryAcquireSharedNanos      | 共享地获取资源（限时等待） |

######  资源释放操作

| 修饰符       | 方法名        | 描述         |
| ------------ | ------------- | ------------ |
| public final | release       | 释放独占资源 |
| public final | releaseShared | 释放共享资源 |





---

### juc-atomic 原子类







---

### juc-sync 同步器







---

### juc-collections 集合





---

### juc-executors 执行器